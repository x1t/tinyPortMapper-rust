//! tinyPortMapper Rust 重写版本
//!
//! 轻量级高性能端口映射/转发工具

pub mod config;
pub mod connection;
#[macro_use]
pub mod event;
pub mod fd_manager;
pub mod log;
pub mod lru;
pub mod manager;
pub mod stats;
pub mod types;

// Include the build module generated by build.rs
include!(concat!(env!("OUT_DIR"), "/build.rs"));

pub use fd_manager::{Fd64, FdManager};
pub use log::{
    get_current_time, is_about_to_exit, set_about_to_exit, LogLevel, Logger, MY_DEBUG_MODE,
};

// 跨平台 RawFd 类型别名（定义在开头供其他函数使用）
#[cfg(unix)]
pub(crate) type PlatformRawFd = std::os::unix::io::RawFd;

#[cfg(windows)]
pub(crate) type PlatformRawFd = std::os::windows::io::RawSocket;

/// 获取当前时间戳（微秒）
///
/// 类似 C++ 版本的 get_current_time_us()，带时间修正
/// 修正逻辑：确保时间戳单调递增，处理系统时间回跳
pub fn get_current_time_us() -> u64 {
    use std::sync::atomic::{AtomicU64, Ordering};
    use std::time::SystemTime;

    static VALUE_FIX: AtomicU64 = AtomicU64::new(0);
    static LARGEST_VALUE: AtomicU64 = AtomicU64::new(0);

    let raw_value = (SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs_f64()
        * 1_000_000.0) as u64;

    let mut value_fix = VALUE_FIX.load(Ordering::Relaxed);
    let mut largest_value = LARGEST_VALUE.load(Ordering::Relaxed);

    let fixed_value = raw_value + value_fix;

    if fixed_value < largest_value {
        value_fix += largest_value - fixed_value;
    } else {
        largest_value = fixed_value;
    }

    VALUE_FIX.store(value_fix, Ordering::Relaxed);
    LARGEST_VALUE.store(largest_value, Ordering::Relaxed);

    raw_value + value_fix
}

/// DJB2 哈希函数
///
/// 返回 u32 哈希值（网络字节序）
pub fn djb2(data: &[u8]) -> u32 {
    let mut hash: u32 = 5381;
    for &c in data {
        hash = ((hash << 5) + hash) ^ c as u32; // hash * 33 ^ c
    }
    hash.to_be()
}

/// SDBM 哈希函数
///
/// 返回 u32 哈希值（使用包装运算避免溢出）
pub fn sdbm(data: &[u8]) -> u32 {
    let mut hash: u32 = 0;
    for &c in data {
        hash = (c as u32)
            .wrapping_add(hash.wrapping_shl(6))
            .wrapping_add(hash.wrapping_shl(16))
            .wrapping_sub(hash);
    }
    hash
}

/// 写 u16 到字节数组（网络字节序）
pub fn write_u16(data: &mut [u8], val: u16) {
    data[0] = (val >> 8) as u8;
    data[1] = val as u8;
}

/// 从字节数组读取 u16（网络字节序）
pub fn read_u16(data: &[u8]) -> u16 {
    u16::from_be_bytes([data[0], data[1]])
}

/// 写 u32 到字节数组（网络字节序）
pub fn write_u32(data: &mut [u8], val: u32) {
    data.copy_from_slice(&val.to_be_bytes());
}

/// 从字节数组读取 u32（网络字节序）
pub fn read_u32(data: &[u8]) -> u32 {
    u32::from_be_bytes([data[0], data[1], data[2], data[3]])
}

/// 写 u64 到字节数组（网络字节序）
pub fn write_u64(data: &mut [u8], val: u64) {
    data.copy_from_slice(&val.to_be_bytes());
}

/// 从字节数组读取 u64（网络字节序）
pub fn read_u64(data: &[u8]) -> u64 {
    u64::from_be_bytes([
        data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7],
    ])
}

/// 网络字节序转换（64位）
pub fn ntoh64(val: u64) -> u64 {
    u64::from_be(val)
}

/// 主机字节序转换（64位）
pub fn hton64(val: u64) -> u64 {
    val.to_be()
}

/// 获取 socket 错误描述
pub fn get_sock_error() -> String {
    std::io::Error::last_os_error().to_string()
}

/// 获取 socket 错误码
pub fn get_sock_errno() -> i32 {
    std::io::Error::last_os_error().raw_os_error().unwrap_or(0)
}

/// 设置非阻塞 socket
#[cfg(unix)]
pub fn set_nonblocking(fd: std::os::unix::io::RawFd) -> std::io::Result<()> {
    let flags = unsafe { libc::fcntl(fd, libc::F_GETFL) };
    if flags < 0 {
        return Err(std::io::Error::last_os_error());
    }
    let ret = unsafe { libc::fcntl(fd, libc::F_SETFL, flags | libc::O_NONBLOCK) };
    if ret < 0 {
        return Err(std::io::Error::last_os_error());
    }
    Ok(())
}

/// 设置非阻塞 socket (Windows)
#[cfg(windows)]
pub fn set_nonblocking(fd: std::os::windows::io::RawSocket) -> std::io::Result<()> {
    use std::os::windows::io::AsRawSocket;
    unsafe {
        let mut nonblocking: u32 = 1;
        let result = libc::ioctlsocket(
            fd.as_raw_socket() as std::os::windows::io::RawSocket,
            libc::FIONBIO,
            &nonblocking as *const _ as *mut libc::c_void,
        );
        if result != 0 {
            return Err(std::io::Error::last_os_error());
        }
    }
    Ok(())
}

/// 设置 socket 缓冲区大小
pub fn set_buf_size(fd: PlatformRawFd, size: usize) -> std::io::Result<()> {
    let sz = size as libc::socklen_t;
    unsafe {
        if libc::setsockopt(
            fd,
            libc::SOL_SOCKET,
            libc::SO_SNDBUF,
            &sz as *const _ as *const libc::c_void,
            std::mem::size_of::<libc::socklen_t>() as libc::socklen_t,
        ) < 0
        {
            return Err(std::io::Error::last_os_error());
        }
        if libc::setsockopt(
            fd,
            libc::SOL_SOCKET,
            libc::SO_RCVBUF,
            &sz as *const _ as *const libc::c_void,
            std::mem::size_of::<libc::socklen_t>() as libc::socklen_t,
        ) < 0
        {
            return Err(std::io::Error::last_os_error());
        }
    }
    Ok(())
}

/// my_ntoa - 将 IPv4 地址 u32 转换为点分十进制字符串
///
/// 对应 C++ 版本: `char * my_ntoa(u32_t ip)`
#[cfg(unix)]
pub fn my_ntoa(ip: u32) -> String {
    let octet1 = (ip >> 24) & 0xFF;
    let octet2 = (ip >> 16) & 0xFF;
    let octet3 = (ip >> 8) & 0xFF;
    let octet4 = ip & 0xFF;
    format!("{}.{}.{}.{}", octet1, octet2, octet3, octet4)
}

/// my_ntoa - Windows 版本
#[cfg(windows)]
pub fn my_ntoa(ip: u32) -> String {
    use std::ptr;
    let mut addr: libc::in_addr = unsafe { std::mem::zeroed() };
    unsafe {
        addr.s_addr = ip.to_be();
        let mut buf: [i8; 16] = [0; 16];
        if libc::inet_ntop(
            libc::AF_INET,
            &addr as *const _ as *const libc::c_void,
            buf.as_mut_ptr() as *mut libc::c_char,
            16,
        ) != ptr::null_mut()
        {
            unsafe { std::ffi::CStr::from_ptr(buf.as_ptr()) }
                .to_string_lossy()
                .into_owned()
        } else {
            format!(
                "{}.{}.{}.{}",
                (ip >> 24) & 0xFF,
                (ip >> 16) & 0xFF,
                (ip >> 8) & 0xFF,
                ip & 0xFF
            )
        }
    }
}

/// larger_than_u16 - 检查 a 是否大于 b（考虑 u16 溢出）
///
/// 对应 C++ 版本: `bool larger_than_u16(uint16_t a,uint16_t b)`
#[inline]
pub fn larger_than_u16(a: u16, b: u16) -> bool {
    a.wrapping_sub(b) > 0
}

/// larger_than_u32 - 检查 a 是否大于 b（考虑 u32 溢出）
///
/// 对应 C++ 版本: `bool larger_than_u32(u32_t a,u32_t b)`
#[inline]
pub fn larger_than_u32(a: u32, b: u32) -> bool {
    a.wrapping_sub(b) > 0
}

/// round_up_div - 向上取整除法
///
/// 对应 C++ 版本: `int round_up_div(int a,int b)`
#[inline]
pub fn round_up_div(a: i32, b: i32) -> i32 {
    (a + b - 1) / b
}

/// 导出构建信息模块（供主程序使用）
pub mod build {
    include!(concat!(env!("OUT_DIR"), "/build_mod.rs"));
}

// ANSI 颜色码 - 导出供宏使用
#[doc(hidden)]
pub const RESET: &str = "\x1b[0m";
#[doc(hidden)]
pub const RED: &str = "\x1b[31m";
#[doc(hidden)]
pub const GREEN: &str = "\x1b[32m";
#[doc(hidden)]
pub const YELLOW: &str = "\x1b[33m";
#[doc(hidden)]
pub const MAGENTA: &str = "\x1b[35m";
#[doc(hidden)]
pub const CYAN: &str = "\x1b[36m";

/// Internal helper function for formatted logging with position
#[doc(hidden)]
#[cfg(not(feature = "my_debug"))]
pub fn format_log_with_position(
    level: LogLevel,
    _file: &str,
    _line: u32,
    caller_file: &str,
    caller_line: u32,
    caller_function: &str,
    args: std::fmt::Arguments<'_>,
) {
    let logger = Logger::global();
    if !logger.is_enabled(level) {
        return;
    }

    let color = if logger.is_color_enabled() {
        match level {
            LogLevel::Fatal => RED,
            LogLevel::Error => RED,
            LogLevel::Warn => YELLOW,
            LogLevel::Info => GREEN,
            LogLevel::Debug => MAGENTA,
            LogLevel::Trace => CYAN,
            _ => RESET,
        }
    } else {
        ""
    };

    // 获取当前时间并格式化为 C++ 风格的时间戳 (YYYY-MM-DD HH:MM:SS)
    let timestamp = {
        use std::time::SystemTime;
        let now = SystemTime::now();
        let datetime: chrono::DateTime<chrono::Local> = now.into();
        datetime.format("%Y-%m-%d %H:%M:%S").to_string()
    };

    let level_str = format!("[{}]", level);
    let mut output = String::new();

    // 格式: [timestamp][LEVEL]
    output.push_str(&format!("[{}]", timestamp));
    output.push_str(color);
    output.push_str(&level_str);
    output.push_str(RESET);

    if logger.is_position_enabled() {
        // 使用调用者的位置信息 (类似 C++ 的 __FILE__:__LINE__:__func__)
        let caller_file_name = caller_file.split('/').next_back().unwrap_or(caller_file);
        // 与 C++ 版本保持一致: [file,func:func_name,line:line_num]
        output.push_str(&format!(
            " [{},func:{},line:{}]",
            caller_file_name, caller_function, caller_line
        ));
    }

    output.push(' ');
    output.push_str(&format!("{}", args));

    // 与 C++ 版本保持一致：FATAL 级别日志时设置 about_to_exit 标记
    if level == LogLevel::Fatal {
        set_about_to_exit();
    }

    println!("{}", output);

    // 同时写入日志文件（无颜色）
    if !output.contains("\x1b[") {
        logger.write_to_file(&output);
    } else {
        // 去除 ANSI 颜色码后写入文件
        let plain_output = strip_ansi_escapes::strip_str(&output);
        logger.write_to_file(&plain_output);
    }
}

/// MY_DEBUG 模式下的简化日志输出 (与 C++ 版本保持一致)
#[doc(hidden)]
#[cfg(feature = "my_debug")]
pub fn format_log_with_position(
    _level: LogLevel,
    _file: &str,
    _line: u32,
    _caller_file: &str,
    _caller_line: u32,
    _caller_function: &str,
    args: std::fmt::Arguments<'_>,
) {
    // MY_DEBUG 模式下直接使用 println!，不添加时间戳、级别和位置信息
    println!("{}", args);
}

/// Internal helper function for bare logging (no timestamp, no level prefix)
#[doc(hidden)]
#[cfg(not(feature = "my_debug"))]
pub fn log_bare_impl(args: std::fmt::Arguments<'_>) {
    print!("{}", args);
}

/// MY_DEBUG 模式下的 bare logging
#[doc(hidden)]
#[cfg(feature = "my_debug")]
pub fn log_bare_impl(args: std::fmt::Arguments<'_>) {
    print!("{}", args);
}

/// Log macro for easy logging with optional position
#[macro_export]
macro_rules! log {
    ($level:expr, $($arg:tt)*) => {
        {
            let location = std::panic::Location::caller();
            $crate::format_log_with_position(
                $level,
                file!(),
                line!(),
                location.file(),
                location.line(),
                "",
                std::format_args!($($arg)*)
            );
        }
    };
}

/// Convenience macro for info level logging
#[macro_export]
macro_rules! info {
    () => { info!("") };
    ($($arg:tt)*) => {
        {
            let location = std::panic::Location::caller();
            $crate::format_log_with_position(
                $crate::log::LogLevel::Info,
                file!(),
                line!(),
                location.file(),
                location.line(),
                "",
                std::format_args!($($arg)*)
            );
        }
    };
}

/// Convenience macro for debug level logging
#[macro_export]
macro_rules! debug {
    () => { debug!("") };
    ($($arg:tt)*) => {
        {
            let location = std::panic::Location::caller();
            $crate::format_log_with_position(
                $crate::log::LogLevel::Debug,
                file!(),
                line!(),
                location.file(),
                location.line(),
                "",
                std::format_args!($($arg)*)
            );
        }
    };
}

/// Convenience macro for warn level logging
#[macro_export]
macro_rules! warn {
    () => { warn!("") };
    ($($arg:tt)*) => {
        {
            let location = std::panic::Location::caller();
            $crate::format_log_with_position(
                $crate::log::LogLevel::Warn,
                file!(),
                line!(),
                location.file(),
                location.line(),
                "",
                std::format_args!($($arg)*)
            );
        }
    };
}

/// Convenience macro for error level logging
#[macro_export]
macro_rules! error {
    () => { error!("") };
    ($($arg:tt)*) => {
        {
            let location = std::panic::Location::caller();
            $crate::format_log_with_position(
                $crate::log::LogLevel::Error,
                file!(),
                line!(),
                location.file(),
                location.line(),
                "",
                std::format_args!($($arg)*)
            );
        }
    };
}

/// Convenience macro for fatal level logging
#[macro_export]
macro_rules! fatal {
    () => { fatal!("") };
    ($($arg:tt)*) => {
        {
            let location = std::panic::Location::caller();
            $crate::format_log_with_position(
                $crate::log::LogLevel::Fatal,
                file!(),
                line!(),
                location.file(),
                location.line(),
                "",
                std::format_args!($($arg)*)
            );
        }
    };
}

/// Convenience macro for trace level logging
#[macro_export]
macro_rules! trace {
    () => { trace!("") };
    ($($arg:tt)*) => {
        {
            let location = std::panic::Location::caller();
            $crate::format_log_with_position(
                $crate::log::LogLevel::Trace,
                file!(),
                line!(),
                location.file(),
                location.line(),
                "",
                std::format_args!($($arg)*)
            );
        }
    };
}

/// Bare logging macro - no timestamp, no level prefix, just raw output
///
/// This is similar to C++'s log_bare() function, used for printing
/// raw data like command line arguments.
#[macro_export]
macro_rules! log_bare {
    ($($arg:tt)*) => {
        {
            $crate::log_bare_impl(std::format_args!($($arg)*));
        }
    };
}

/// 单元测试函数（与 C++ 版本保持一致）
///
/// 用于测试地址解析和哈希函数
pub fn unit_test() {
    use crate::types::Address;
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};

    println!("=== Running unit_test ===");

    // 测试 IPv6 地址解析（与 C++ 版本一致）
    let test1: Address = "[2001:19f0:7001:1111:00:ff:11:22]:443"
        .parse()
        .expect("Failed to parse IPv6 address");
    println!("{}", test1);

    // 计算并打印哈希值（与 C++ 版本的 sdbm 哈希保持一致）
    let mut hasher = DefaultHasher::new();
    test1.hash(&mut hasher);
    let hash1 = hasher.finish();
    println!("{}", hash1);

    // 测试 IPv4 地址解析（与 C++ 版本一致）
    let test2: Address = "44.55.66.77:443"
        .parse()
        .expect("Failed to parse IPv4 address");
    println!("{}", test2);

    let mut hasher = DefaultHasher::new();
    test2.hash(&mut hasher);
    let hash2 = hasher.finish();
    println!("{}", hash2);

    println!("=== unit_test completed ===");
}

/// pack_u64 - 将两个 u32 打包成一个 u64
///
/// 对应 C++ 版本: `u64_t pack_u64(u32_t a, u32_t b)`
#[inline]
pub fn pack_u64(a: u32, b: u32) -> u64 {
    ((a as u64) << 32) | (b as u64)
}

/// get_u64_h - 获取 u64 的高位 u32
///
/// 对应 C++ 版本: `u32_t get_u64_h(u64_t a)`
#[inline]
pub fn get_u64_h(a: u64) -> u32 {
    (a >> 32) as u32
}

/// get_u64_l - 获取 u64 的低位 u32
///
/// 对应 C++ 版本: `u32_t get_u64_l(u64_t a)`
#[inline]
pub fn get_u64_l(a: u64) -> u32 {
    (a & 0xFFFFFFFF) as u32
}

/// 64位伪随机数生成器
///
/// 使用线性同余生成器 (LCG) 实现，与 C++ 版本保持一致
static RANDOM_STATE: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);

/// 初始化随机数生成器
///
/// 对应 C++ 版本: `void init_random_number_fd()`
pub fn init_random_number_fd() {
    // 使用当前时间和一些随机源初始化
    let seed = get_current_time_us()
        .wrapping_add(std::process::id() as u64)
        .wrapping_add(
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
        );
    RANDOM_STATE.store(seed, std::sync::atomic::Ordering::Relaxed);
}

/// 获取 64位伪随机数
///
/// 对应 C++ 版本: `u64_t get_fake_random_number_64()`
pub fn get_fake_random_number_64() -> u64 {
    // 使用简单的 LCG 算法
    //  constants from https://en.wikipedia.org/wiki/Linear_congruential_generator
    const MULTIPLIER: u64 = 6364136223846793005;
    const INCREMENT: u64 = 1442695040888963407;

    let state = RANDOM_STATE.load(std::sync::atomic::Ordering::Relaxed);
    let new_state = state.wrapping_mul(MULTIPLIER).wrapping_add(INCREMENT);
    RANDOM_STATE.store(new_state, std::sync::atomic::Ordering::Relaxed);

    // 增加一些熵：混合时间戳
    new_state ^ get_current_time_us()
}

/// 获取 32位伪随机数
///
/// 对应 C++ 版本: `u32_t get_fake_random_number()`
#[inline]
pub fn get_fake_random_number() -> u32 {
    get_fake_random_number_64() as u32
}

/// 获取非零 32位伪随机数
///
/// 对应 C++ 版本: `u32_t get_fake_random_number_nz()`
pub fn get_fake_random_number_nz() -> u32 {
    loop {
        let ret = get_fake_random_number();
        if ret != 0 {
            return ret;
        }
    }
}

/// 生成随机字符
///
/// 对应 C++ 版本: `void get_fake_random_chars(char * s, int len)`
pub fn get_fake_random_chars(len: usize) -> String {
    const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let mut result = String::with_capacity(len);
    for _ in 0..len {
        let idx = get_fake_random_number() as usize % CHARSET.len();
        result.push(CHARSET[idx] as char);
    }
    result
}

/// 生成范围 [a, b] 内的随机数
///
/// 对应 C++ 版本: `int random_between(u32_t a, u32_t b)`
pub fn random_between(a: u32, b: u32) -> u32 {
    if a > b {
        panic!("random_between: min > max ({} > {})", a, b);
    }
    if a == b {
        return a;
    }
    // 使用 u64 避免溢出
    let range = (b as u64) - (a as u64) + 1;
    let offset = get_fake_random_number() as u64 % range;
    (a as u64 + offset) as u32
}

/// myexit - 优雅退出函数（与 C++ 版本保持一致）
///
/// 对应 C++ 版本: `void myexit(int a)`
/// 功能：
/// 1. 重置终端颜色（如果启用）
/// 2. 调用 std::process::exit() 退出
#[cfg(unix)]
pub fn myexit(code: i32) -> ! {
    use std::io::Write;

    // 重置终端颜色（与 C++ 版本保持一致）
    let logger = Logger::global();
    if logger.is_color_enabled() {
        let _ = std::io::stdout().write_all(RESET.as_bytes());
        let _ = std::io::stdout().flush();
    }

    std::process::exit(code)
}

/// myexit - Windows 版本的优雅退出函数
#[cfg(windows)]
pub fn myexit(code: i32) -> ! {
    use std::io::Write;

    // Windows 终端颜色重置
    let _ = std::io::stdout().write_all(RESET.as_bytes());
    let _ = std::io::stdout().flush();

    std::process::exit(code)
}

#[cfg(test)]
mod random_tests {
    use super::*;

    #[test]
    fn test_pack_u64() {
        let result = pack_u64(0x12345678, 0xABCDEF01);
        assert_eq!(result, 0x12345678ABCDEF01);
    }

    #[test]
    fn test_get_u64_h() {
        let val: u64 = 0x12345678ABCDEF01;
        assert_eq!(get_u64_h(val), 0x12345678);
    }

    #[test]
    fn test_get_u64_l() {
        let val: u64 = 0x12345678ABCDEF01;
        assert_eq!(get_u64_l(val), 0xABCDEF01);
    }

    #[test]
    fn test_pack_and_unpack() {
        let high: u32 = 0xDEADBEEF;
        let low: u32 = 0xCAFEBABE;
        let packed = pack_u64(high, low);
        assert_eq!(get_u64_h(packed), high);
        assert_eq!(get_u64_l(packed), low);
    }

    #[test]
    fn test_get_fake_random_number() {
        // 测试随机数生成器能生成多个不同的值
        init_random_number_fd();
        let v1 = get_fake_random_number();
        let v2 = get_fake_random_number();
        let v3 = get_fake_random_number();
        // 多次调用应该生成不同的值（概率极低会相同）
        assert_ne!(v1, v2);
        assert_ne!(v2, v3);
        // 范围应该在 u32 范围内
        assert!(v1 <= u32::MAX);
        assert!(v2 <= u32::MAX);
    }

    #[test]
    fn test_get_fake_random_number_64() {
        init_random_number_fd();
        let v1 = get_fake_random_number_64();
        let v2 = get_fake_random_number_64();
        assert_ne!(v1, v2);
        assert!(v1 <= u64::MAX);
        assert!(v2 <= u64::MAX);
    }

    #[test]
    fn test_get_fake_random_number_nz() {
        init_random_number_fd();
        // 多次调用，确保生成的值非零
        for _ in 0..100 {
            let v = get_fake_random_number_nz();
            assert_ne!(v, 0);
        }
    }

    #[test]
    fn test_get_fake_random_chars() {
        init_random_number_fd();
        let chars = get_fake_random_chars(32);
        assert_eq!(chars.len(), 32);
        // 验证只包含字母数字字符
        for c in chars.chars() {
            assert!(c.is_ascii_alphanumeric(), "Invalid character: {}", c);
        }
    }

    #[test]
    fn test_random_between() {
        init_random_number_fd();
        // 测试边界情况
        assert_eq!(random_between(5, 5), 5);

        // 测试范围
        for _ in 0..100 {
            let r = random_between(10, 20);
            assert!(r >= 10 && r <= 20, "Value {} out of range", r);
        }

        // 测试最大范围
        for _ in 0..100 {
            let r = random_between(0, u32::MAX);
            assert!(r <= u32::MAX);
        }
    }
}
